{
    "version": "https://jsonfeed.org/version/1",
    "title": "Nithish Kumar Megarajan",
    "home_page_url": "https://nithishk.com/",
    "feed_url": "https://nithishk.com/feed.json",
    "description": "Nithish's Website",
    "icon": "https://nithishk.com/avatar.jpeg",
    "author": {
        "name": "Nithish Kumar Megarajan",
        "url": "https://nithishk.com"
    },
    "items": [
        {
            "content_html": "<p>I’ve been working through <strong>FIT5047 — Assignment 1: Search</strong>.<br>\nIt looks like a toy game; it isn’t. It’s a tight exercise in <em>problem modeling, admissible heuristics, and engineering discipline</em> under timeouts.</p>\n<p>Below is a engineering-oriented write-up of how I approached <strong>Q1a (single dot)</strong>, <strong>Q1b (reach any one of many dots)</strong>, and <strong>Q1c (maximize score with many dots)</strong> — plus what I learned.</p>\n<hr>\n<ul>\n<li><strong>Optimal pathfinding:</strong> A* with <strong>Manhattan</strong> on unit grids + a clean stale-entry guard + <code>(f, h)</code> tie-break.</li>\n<li><strong>Reach any dot efficiently:</strong> A* with a <strong>perfect nearest-food heuristic</strong> from a <strong>multi-source BFS</strong> precompute (exact maze distance to the nearest dot for every cell).</li>\n<li><strong>Maximize score with many dots:</strong> A layered planner:\n<ol>\n<li><strong>Greedy with 3-step lookahead</strong> (walls-aware distances),</li>\n<li><strong>Exact finisher</strong> (Held–Karp DP over maze distances) when few dots remain,</li>\n<li><strong>Robust fallback</strong>: state-space <strong>A*</strong> using a <strong>maze-distance MST heuristic</strong>.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2>Project Shape</h2>\n<p>The codebase separates <strong>problem modeling</strong> from <strong>algorithms</strong>:</p>\n<ul>\n<li><code>problems/*.py</code> → <code>getStartState()</code>, <code>isGoalState(state)</code>, <code>getSuccessors(state)</code></li>\n<li><code>solvers/*.py</code> → returns a <strong>list of Directions</strong> (the plan)</li>\n</ul>\n<p>This lets me iterate on heuristics and strategies without touching environment code.</p>\n<hr>\n<h2>Core Ideas &amp; How They Work</h2>\n<h3>1) Optimal point-to-point paths (single target)</h3>\n<ul>\n<li><strong>State:</strong> <code>(x, y)</code></li>\n<li><strong>Moves:</strong> N/S/E/W, cost = 1</li>\n<li><strong>Heuristic:</strong> <code>h = Manhattan</code> (admissible &amp; consistent on unit grids)</li>\n</ul>\n<p><strong>A*</strong> essentials</p>\n<ul>\n<li>Priority <code>f = g + h</code></li>\n<li><strong>Stale-entry guard</strong> so outdated PQ entries don’t cause extra expansions:<pre><code class=\"language-python\">state, g = frontier.pop()\nif g != best_g.get(state, float(&quot;inf&quot;)):\n    continue\n</code></pre>\n</li>\n<li><strong>Tie-break</strong> with <code>(f, h)</code> so equal-<code>f</code> nodes with smaller <code>h</code> expand first (plateau trimming).</li>\n</ul>\n<p><strong>Why it works:</strong> Consistent <code>h</code> ⇒ the first goal popped is optimal; the tie-break quietly reduces expansions.</p>\n<hr>\n<h3>2) Reach any one of many dots with minimal expansions</h3>\n<p>Plain Manhattan to the <strong>nearest</strong> dot still expands too much on twisty maps. I precompute the <strong>exact distance to the nearest dot for every cell</strong>:</p>\n<pre><code class=\"language-python\"># Multi-source BFS, seeded by all food cells at distance 0\ndist = [[INF]*H for _ in range(W)]\nQ = Queue()\nfor (fx, fy) in foods:\n    dist[fx][fy] = 0\n    Q.push((fx, fy))\n\nwhile not Q.isEmpty():\n    x, y = Q.pop()\n    for nx, ny in neighbors((x, y)):\n        if dist[nx][ny] &gt; dist[x][y] + 1:\n            dist[nx][ny] = dist[x][y] + 1\n            Q.push((nx, ny))\n</code></pre>\n<p><strong>Heuristic query during A*:</strong><br>\n<code>h(state) = dist[state.x][state.y]</code> → exact nearest-food distance.</p>\n<p>This <code>h</code> is <strong>admissible, consistent, and exact</strong> for “nearest food”. I keep the <code>(f, h)</code> tie-break to reduce plateaus further.</p>\n<p><strong>Why it works:</strong> Precomputation turns heuristic queries into <strong>O(1)</strong> exact answers; expansions drop sharply.</p>\n<hr>\n<h3>3) Maximize score across many dots (10 per dot, −1 per step)</h3>\n<p>This is a <strong>sequencing</strong> problem: eat lots of dots while avoiding long, low-yield treks. I use a <strong>layered planner</strong>:</p>\n<h4>3.1 Greedy with <strong>3-step lookahead</strong> (walls-aware)</h4>\n<ul>\n<li>From the current position, run <strong>BFS</strong> → exact maze distances to all cells + parent map.</li>\n<li>Consider top <strong>K₁</strong> nearest dots; for each candidate <code>f₁</code>:\n<ul>\n<li>Estimate the best <code>f₂</code> and <code>f₃</code> using <strong>cached BFS grids</strong> from <code>f₁</code> and <code>f₂</code>.</li>\n<li><strong>Score:</strong><pre><code>(10 - d1)_+ + (10 - d2)_+ + 0.8·(10 - d3)_+ + 0.05·local_density\n</code></pre>\nwhere <code>local_density</code> = #dots within Manhattan radius 3 around <code>f₁</code> (cluster bias).</li>\n</ul>\n</li>\n<li>Reconstruct the <strong>shortest path</strong> via BFS parents; <strong>consume dots encountered</strong> along the way.</li>\n</ul>\n<h4>3.2 <strong>Exact finisher</strong> when few dots remain</h4>\n<ul>\n<li>When remaining dots ≤ <strong>12</strong>, switch to <strong>Held–Karp DP</strong> over <strong>maze distances</strong>:\n<ul>\n<li>Build a pairwise distance matrix between remaining dots using cached BFS grids.</li>\n<li>Run TSP-style <strong>DP</strong> to get the shortest tour; stitch edges back into actions via BFS.</li>\n</ul>\n</li>\n</ul>\n<h4>3.3 Safety net — Full state-space <strong>A*</strong> over <code>(position, food_grid)</code></h4>\n<p>On pathological layouts, the greedy seed can fail (e.g., tight “closed” mazes). I fall back to A* with a <strong>tight, admissible heuristic</strong>:</p>\n<ul>\n<li><code>h = nearest_maze_distance(position → any food) + MST(remaining foods)</code><br>\nwhere the MST runs on <strong>maze distances</strong> (Prim’s), not Manhattan.</li>\n<li><strong>Neighbors</strong> come from <code>Actions.getLegalNeighbors</code> (engine’s logic) for correctness in quirky passages.</li>\n<li>Maze distances between points are <strong>cached</strong>.</li>\n</ul>\n<p><strong>Why it works:</strong> Greedy + lookahead harvests dense clusters efficiently; the DP <strong>finishes optimally</strong> when small; the A* fallback is <strong>complete</strong> and typically well within the time budget thanks to the tight MST heuristic.</p>\n<hr>\n<h2>Code Snippets (Illustrative)</h2>\n<p><strong>A* scaffold</strong></p>\n<pre><code class=\"language-python\">class AStarData:\n    def __init__(self):\n        self.frontier = util.PriorityQueue()\n        self.best_g   = {}               # state -&gt; g\n        self.parent   = {}               # state -&gt; (prev, action)\n        self.start    = None\n        self.solved   = False\n        self.solution = []\n</code></pre>\n<p><strong>Walls-aware BFS</strong></p>\n<pre><code class=\"language-python\">def bfs_all(start):\n    dist   = [[None]*H for _ in range(W)]\n    parent = {}\n    q = util.Queue()\n    dist[start.x][start.y] = 0\n    q.push(start)\n    while not q.isEmpty():\n        u = q.pop()\n        for v, action in neighbors(u):   # engine-legal neighbors\n            if dist[v.x][v.y] is None:\n                dist[v.x][v.y] = dist[u.x][u.y] + 1\n                parent[v] = (u, action)\n                q.push(v)\n    return dist, parent\n</code></pre>\n<p><strong>Held–Karp DP</strong></p>\n<pre><code class=\"language-python\"># dp[mask][j] = shortest cost to visit subset 'mask' ending at j\nfor mask in range(1&lt;&lt;n):\n    for j in range(n):\n        if mask &amp; (1&lt;&lt;j):\n            # transition to k not in mask using pairwise maze distances\n</code></pre>\n<p><strong>MST heuristic on maze distances (tight &amp; admissible)</strong></p>\n<pre><code class=\"language-python\">def mst_len_maze(points):\n    # Prim's over points with edge weights = maze_dist(a, b) via cached BFS\n    ...\n</code></pre>\n<hr>\n<h2>How I Run It</h2>\n<blockquote>\n<p>Flags vary by template; check <code>python evaluator.py</code>.</p>\n</blockquote>\n<p><strong>Single instances</strong></p>\n<pre><code class=\"language-bash\">python pacman.py -l layouts/smallMaze.lay   -p SearchAgent -a fn=solverA,prob=problemA --timeout=1\npython pacman.py -l layouts/someCorners.lay -p SearchAgent -a fn=solverB,prob=problemB --timeout=5\npython pacman.py -l layouts/tinySearch.lay  -p SearchAgent -a fn=solverC,prob=problemC --timeout=10\n</code></pre>\n<p><strong>Local evaluator</strong></p>\n<pre><code class=\"language-bash\">python evaluator.py --q1a --q1b --q1c\n# Pretty tables need: pip install tabulate\n</code></pre>\n<hr>\n<h2>Troubleshooting</h2>\n<ul>\n<li><strong>“layout file cannot be found”</strong> → check name or <code>ls layouts</code>.</li>\n<li><strong><code>util.raiseNotDefined()</code> crash</strong> → a placeholder wasn’t replaced.</li>\n<li><strong>Slow or timeouts</strong>\n<ul>\n<li>Enforce the <strong>stale-entry guard</strong> in A*.</li>\n<li>Cache BFS distance grids from frequently used anchors (food cells).</li>\n<li>Keep lookahead <strong>beam sizes</strong> modest (<code>K1=12, K2=6, K3=3</code>).</li>\n</ul>\n</li>\n<li><strong>Evaluator markdown ImportError</strong> → <code>python -m pip install tabulate</code>.</li>\n</ul>\n<hr>\n<h2>What I Learned</h2>\n<ul>\n<li><strong>Heuristic design is a lever:</strong> admissible + consistent yields correctness guarantees; tightness yields speed.</li>\n<li><strong>Tie-breaks matter:</strong> <code>(f, h)</code> reduces expansions with zero risk.</li>\n<li><strong>Exploit static structure:</strong> on fixed maps, <strong>precompute</strong> (multi-source BFS, cached grids).</li>\n<li><strong>Layered planning:</strong> greedy for speed, DP for optimal finish, A* as a safety net is a pragmatic “meta-planner”.</li>\n<li><strong>Determinism + caching</strong> → predictable, fast runs that play nicely with timeouts.</li>\n</ul>\n<hr>\n<h2>Notes on Publishing</h2>\n<ul>\n<li>I keep course-provided starter code <strong>private</strong>.</li>\n<li>This README contains my own explanations and small illustrative snippets only.</li>\n</ul>\n",
            "url": "https://nithishk.com/posts/pacman",
            "title": "Pac-Man, Optimally — Heuristics, Search & Engineering Notes from FIT5047 A1",
            "summary": "What I built and learned while implementing A* search, heuristics, and score-maximizing strategies for the FIT5047 Pac-Man assignment (Q1a–Q1c).",
            "date_modified": "2025-08-19T00:00:00.000Z",
            "author": {
                "name": "Nithish Kumar Megarajan",
                "url": "https://nithishk.com"
            }
        },
        {
            "content_html": "<p><strong><a href=\"http://Weava.ai\">Weava.ai</a></strong> is a new kind of AI email assistant — not one that suggests drafts or filters spam — but one that actually <strong>thinks, replies, and organizes your inbox</strong> for you.</p>\n<p>Inspired by real email burnout, the app introduces a calm, decision-free interface we call <strong>Inbox Zen View</strong>:<br>\n📥 <strong>To Read</strong> | ✅ <strong>Handled</strong> | 🚫 <strong>Ignored</strong><br>\nEach section is powered by AI and updated in real time.</p>\n<hr>\n<h2>🧠 Why <a href=\"http://Weava.ai\">Weava.ai</a>?</h2>\n<p>Because Gmail, Outlook, and iCloud all have “smart suggestions”…<br>\nBut no one <strong>actually handles the inbox</strong> for you.<br>\nWeava does.</p>\n<ul>\n<li>It connects to all your email accounts</li>\n<li>Understands which emails are urgent, ignorable, or routine</li>\n<li><strong>Replies automatically</strong> to known cases using your tone</li>\n<li>And sends you a <strong>daily digest</strong> of what it did (including updated calendars)</li>\n</ul>\n<hr>\n<h2>🔨 Phase 1 – Building the Brain</h2>\n<p>This first development phase is all about the backend logic:</p>\n<ul>\n<li>Ingesting raw email content</li>\n<li>Running AI summarization + classification</li>\n<li>Drafting or auto-sending replies</li>\n<li>Storing all data for UI rendering</li>\n</ul>\n<hr>\n<h2>🔁 What AI Does in Phase 1</h2>\n<ol>\n<li><strong>Reads</strong> the email body + metadata</li>\n<li><strong>Summarizes</strong> the content</li>\n<li><strong>Classifies</strong> it as:\n<ul>\n<li><code>To Read</code> – human should read</li>\n<li><code>Handled</code> – AI replied/archived</li>\n<li><code>Ignored</code> – newsletters, spam, FYIs</li>\n</ul>\n</li>\n<li><strong>Replies</strong> with context-aware, tone-matched text</li>\n<li><strong>Logs</strong> the reply + updates your calendar if needed</li>\n</ol>\n<hr>\n<h2>✨ Sample Prompt Used in Phase 1</h2>\n<pre><code class=\"language-txt\">You are an AI email assistant.\nYour job is to:\n1. Classify this email into one of: To Read, Handled, Ignored\n2. Provide a one-line summary\n3. Suggest a short, polite reply\n\nEmail Subject: &quot;Following up on the proposal&quot;\nEmail Body: &quot;Hi! Just checking in to see if you had a chance to review the pitch I sent last week.&quot;\n</code></pre>\n<h2>✨ Sample Output in Phase 1</h2>\n<pre><code class=\"language-json\">{\n  &quot;category&quot;: &quot;To Read&quot;,\n  &quot;summary&quot;: &quot;Client is following up on last week's proposal.&quot;,\n  &quot;reply&quot;: &quot;Thanks for the follow-up! I’ll take a look and get back to you by today.&quot;\n}\n</code></pre>\n",
            "url": "https://nithishk.com/posts/weava",
            "title": "Inbox, Handled – Building Weava.ai, an AI Email Assistant",
            "summary": "Building Weava.ai – an AI-powered multi-inbox assistant that reads, replies, and organizes your email while you focus on real work.",
            "date_modified": "2025-06-20T00:00:00.000Z",
            "author": {
                "name": "Nithish Kumar Megarajan",
                "url": "https://nithishk.com"
            }
        }
    ]
}